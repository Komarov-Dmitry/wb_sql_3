--ЧАСТЬ 1

--Задание 1:
--Выведите список сотрудников с именами сотрудников, получающими самую высокую зарплату в отделе. Столбцы в результирующей таблице: first_name, last_name, salary, industry, name_ighest_sal. Последний столбец - имя сотрудника для данного отдела с самой высокой зарплатой.

--Выведите аналогичный список, но теперь укажите сотрудников с минимальной зарплатой.

--В каждом случае реализуйте расчет двумя способами: с использованием функций min max (без оконных функций) и с использованием first/last value

-- В этом CTE я нахожу максимальную зарплату для каждого отдела.
WITH max_salary_per_industry AS (
    SELECT 
        industry,                 -- Выбираю отдел
        MAX(salary) AS max_salary -- Нахожу максимальную зарплату в этом отделе
    FROM salary
    GROUP BY industry            -- Группирую данные по отделам, чтобы для каждого отдела получить одну строку с максимальной зарплатой
),

-- В этом CTE я определяю сотрудников, которые получают максимальную зарплату в своем отделе.
max_salary_employee AS (
    SELECT 
        s.industry,                   -- Отдел, в котором работает сотрудник
        s.first_name AS name_ighest_sal -- Имя сотрудника, получающего максимальную зарплату в своем отделе
    FROM salary s
    JOIN max_salary_per_industry mspi  -- Соединяю таблицу зарплат с результатами из предыдущего шага
        ON s.industry = mspi.industry  -- Сопоставляю отделы
       AND s.salary = mspi.max_salary  -- Беру только тех сотрудников, чья зарплата равна максимальной в их отделе
)

-- Основной запрос: я соединяю исходную таблицу с результатами второго CTE.
SELECT 
    s.first_name,             -- Имя текущего сотрудника
    s.last_name,              -- Фамилия текущего сотрудника
    s.industry,               -- Отдел, в котором работает текущий сотрудник
    mse.name_ighest_sal       -- Имя сотрудника с самой высокой зарплатой в этом отделе
FROM salary s
JOIN max_salary_employee mse  -- Соединяю текущего сотрудника с таблицей, где есть информация о сотрудниках с максимальной зарплатой
    ON s.industry = mse.industry; -- Сопоставляю записи по отделу







--Выведите аналогичный список, но теперь укажите сотрудников с минимальной зарплатой.










-- В этом CTE я нахожу минимальную зарплату для каждого отдела.
WITH min_salary_per_industry AS (
    SELECT 
        industry,                 -- Выбираю отдел
        MIN(salary) AS min_salary -- Нахожу минимальную зарплату в этом отделе
    FROM salary
    GROUP BY industry            -- Группирую данные по отделам, чтобы для каждого отдела получить одну строку с минимальной зарплатой
),

-- В этом CTE я определяю сотрудников, которые получают минимальную зарплату в своем отделе.
min_salary_employee AS (
    SELECT 
        s.industry,                   -- Отдел, в котором работает сотрудник
        s.first_name AS name_lowest_sal -- Имя сотрудника, получающего минимальную зарплату в своем отделе
    FROM salary s
    JOIN min_salary_per_industry mspi  -- Соединяю таблицу зарплат с результатами из предыдущего шага
        ON s.industry = mspi.industry  -- Сопоставляю отделы
       AND s.salary = mspi.min_salary  -- Беру только тех сотрудников, чья зарплата равна минимальной в их отделе
)

-- Основной запрос: я соединяю исходную таблицу с результатами второго CTE.
SELECT 
    s.first_name,             -- Имя текущего сотрудника
    s.last_name,              -- Фамилия текущего сотрудника
    s.salary,                 -- Зарплата текущего сотрудника
    s.industry,               -- Отдел, в котором работает текущий сотрудник
    mse.name_lowest_sal       -- Имя сотрудника с самой низкой зарплатой в этом отделе
FROM salary s
JOIN min_salary_employee mse  -- Соединяю текущего сотрудника с таблицей, где есть информация о сотрудниках с минимальной зарплатой
    ON s.industry = mse.industry; -- Сопоставляю записи по отделу
















--FIRST_VALUE AND LAST_VALUE

SELECT 
    first_name,  -- выбираю имя сотрудника
    last_name,   -- выбираю фамилию сотрудника
    industry,    -- выбираю отрасль, в которой работает сотрудник
    first_value(first_name || ' ' || last_name)  -- получаю полное имя самого высокооплачиваемого сотрудника в отрасли
        OVER(PARTITION BY industry  -- группирую по отрасли, чтобы рассматривать сотрудников в рамках одной отрасли
        ORDER BY salary DESC)  -- сортирую сотрудников по зарплате в убывающем порядке, чтобы первое значение было у самого высокооплачиваемого
        AS name_highest_sal  -- столбец, который будет содержать полное имя сотрудника с самой высокой зарплатой в каждой отрасли
FROM salary;







SELECT 
    first_name,  -- выбираю имя сотрудника
    last_name,   -- выбираю фамилию сотрудника
    industry,    -- выбираю отрасль, в которой работает сотрудник
    LAST_VALUE(first_name || ' ' || last_name)  -- получаю полное имя сотрудника с самой низкой зарплатой в отрасли
        OVER (PARTITION BY industry  -- группирую по отрасли, чтобы рассматривать сотрудников в одной отрасли
        ORDER BY salary DESC  -- сортирую по убыванию зарплаты, чтобы самый низкий оклад оказался в конце
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)  -- определяю фрейм, чтобы рассматривать все строки в группе (все сотрудники отрасли)
        AS name_lowest_sal  -- столбец, который будет содержать полное имя сотрудника с самой низкой зарплатой в каждой отрасли
FROM salary;

--Без этого уточнения (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) LAST_VALUE может возвращать неверные результаты, так как по умолчанию окно будет ограничено только текущей строкой и строками, предшествующими ей.
















--ЧАСТЬ 2

--Задание 1:

--Отберите данные по продажам за 2.01.2016. Укажите для каждого магазина его адрес, сумму проданных товаров в штуках, сумму проданных товаров в рублях.

--Столбцы в результирующей таблице:

--SHOPNUMBER , CITY , ADDRESS, SUM_QTY SUM_QTY_PRICE

-- В этом запросе я выбираю данные по продажам за 02.01.2016, рассчитываю количество проданных товаров и общую стоимость проданных товаров для каждого магазина.

SELECT 
    s."SHOPNUMBER",  -- Я выбираю номер магазина из таблицы sales
    sh."CITY",       -- Я беру город магазина из таблицы shops
    sh."ADDRESS",    -- Я беру адрес магазина из таблицы shops
    SUM(s."QTY") AS SUM_QTY,  -- Я суммирую количество проданных товаров для каждого магазина
    SUM(s."QTY" * g."PRICE") AS SUM_QTY_PRICE  -- Я вычисляю общую сумму проданных товаров в рублях, умножая количество на цену товара из таблицы goods
FROM 
    sales s  -- Я использую таблицу sales для информации о продажах
JOIN 
    shops sh ON s."SHOPNUMBER" = sh."SHOPNUMBER"  -- Я соединяю таблицы sales и shops по номеру магазина, чтобы получить информацию о магазине
JOIN 
    goods g ON s."ID_GOOD" = g."ID_GOOD"  -- Я соединяю таблицы sales и goods по ID товара, чтобы получить информацию о товаре, его цене
WHERE 
    s."DATE" = '02.01.2016'  -- Я фильтрую данные по дате продаж, выбирая только продажи за 2 января 2016 года
GROUP BY 
    s."SHOPNUMBER", sh."CITY", sh."ADDRESS"  -- Я группирую данные по магазину, городу и адресу, чтобы посчитать суммы для каждого магазина отдельно
ORDER BY 
    s."SHOPNUMBER";  -- Я сортирую результат по номеру магазина для удобства


--Window function

SELECT 
    s."SHOPNUMBER",
    sh."CITY",
    sh."ADDRESS",
    SUM(s."QTY") OVER (PARTITION BY s."SHOPNUMBER") AS SUM_QTY,  -- Оконная функция для суммы количества товаров по каждому магазину
    SUM(s."QTY" * g."PRICE") OVER (PARTITION BY s."SHOPNUMBER") AS SUM_QTY_PRICE  -- Оконная функция для суммы стоимости товаров по каждому магазину
FROM 
    sales s
JOIN 
    shops sh ON s."SHOPNUMBER" = sh."SHOPNUMBER"
JOIN 
    goods g ON s."ID_GOOD" = g."ID_GOOD"
WHERE 
    s."DATE" = '02.01.2016'
ORDER BY 
    s."SHOPNUMBER";





--Задание 2

--Отберите за каждую дату долю от суммарных продаж (в рублях на дату). Расчеты проводите только по товарам направления ЧИСТОТА.

--Столбцы в результирующей таблице:

--DATE_, CITY, SUM_SALES_REL

SELECT 
    -- Я использую DISTINCT, чтобы выбирать только уникальные сочетания даты и города.
    -- Для каждой уникальной комбинации я хочу получить суммарные продажи.
    DISTINCT s."DATE" AS DATE_,
    
    -- Я добавляю город магазина, используя связь с таблицей "shops" (sh),
    -- через столбец "SHOPNUMBER", чтобы для каждой даты можно было увидеть город.
    sh."CITY",

    -- Я рассчитываю суммарные продажи для каждой комбинации даты и города
    -- с использованием оконной функции SUM() OVER, которая позволяет суммировать продажи.
    -- Я использую "PARTITION BY" по дате и городу, чтобы считать продажи для каждой комбинации.
    -- Это поможет мне посчитать общую сумму по всем товарам категории "ЧИСТОТА" на каждую дату в конкретном городе.
    SUM(s."QTY" * g."PRICE") OVER (PARTITION BY s."DATE", sh."CITY") AS SUM_SALES_REL

-- Я соединяю таблицу "sales" с таблицей "shops" (sh) через поле "SHOPNUMBER",
-- чтобы получить информацию о городе каждого магазина.
FROM 
    sales s
JOIN 
    shops sh ON s."SHOPNUMBER" = sh."SHOPNUMBER"

-- Далее я соединяю таблицу "goods" (g) с таблицей "sales" по полю "ID_GOOD",
-- чтобы получить информацию о товаре, который был продан.
JOIN 
    goods g ON s."ID_GOOD" = g."ID_GOOD"

-- Я фильтрую данные, чтобы учитывать только товары, относящиеся к категории "ЧИСТОТА".
WHERE 
    g."CATEGORY" = 'ЧИСТОТА'

-- Я сортирую результат по дате, чтобы продажи показывались по порядку.
ORDER BY 
    s."DATE";















--Задание 3:

--Выведите информацию о топ-3 товарах по продажам в штуках в каждом магазине в каждую дату.

--Столбцы в результирующей таблице:

--DATE_ , SHOPNUMBER, ID_GOOD


WITH ranked_sales AS (
    SELECT 
        -- Я выбираю поле "DATE" из таблицы sales, чтобы отслеживать, когда были совершены продажи.
        s."DATE",
        
        -- Также выбираю "SHOPNUMBER", чтобы узнать, в каком магазине были сделаны продажи.
        s."SHOPNUMBER",
        
        -- Я добавляю "ID_GOOD", чтобы увидеть, какой товар был продан.
        s."ID_GOOD",
        
        -- Здесь я суммирую количество проданных товаров (QTY) для каждой комбинации товара, магазина и даты.
        SUM(s."QTY") AS total_qty,
        
        -- Я использую оконную функцию RANK(), чтобы присвоить ранг каждому товару в рамках конкретной даты и магазина,
        -- отсортировав товары по убыванию суммарного количества продаж (total_qty).
        -- Это позволит мне выделить топ-3 товара для каждого магазина и даты.
        RANK() OVER (PARTITION BY s."DATE", s."SHOPNUMBER" ORDER BY SUM(s."QTY") DESC) AS rank
    FROM 
        -- Я беру данные из таблицы sales, где хранятся все продажи.
        sales s
    
    -- Группирую по "DATE", "SHOPNUMBER" и "ID_GOOD", чтобы посчитать общее количество для каждого товара в каждом магазине и на каждую дату.
    GROUP BY 
        s."DATE", s."SHOPNUMBER", s."ID_GOOD"
)

-- В основной части запроса я выбираю из CTE ranked_sales те строки, где товар попал в топ-3 по количеству продаж.
SELECT 
    -- Я переименовываю поле "DATE" в "DATE_", чтобы избежать конфликтов с SQL-резервированными словами.
    ranked_sales."DATE" AS DATE_,
    
    -- Я сохраняю "SHOPNUMBER" и "ID_GOOD", чтобы в итоговой таблице была информация о магазине и товаре.
    ranked_sales."SHOPNUMBER",
    ranked_sales."ID_GOOD"
FROM 
    -- Я выбираю данные из CTE ranked_sales.
    ranked_sales

-- Я фильтрую строки, оставляя только те, у которых ранг товара <= 3, то есть топ-3 товара для каждой даты и магазина.
WHERE 
    rank <= 3

-- Я сортирую результаты по дате (DATE_), номеру магазина (SHOPNUMBER) и рангу товара (rank), чтобы видеть топ-3 товара в порядке убывания продаж.
ORDER BY 
    ranked_sales."DATE", ranked_sales."SHOPNUMBER", rank;











--Задание 4:

--Выведите для каждого магазина и товарного направления сумму продаж в рублях за предыдущую дату. Только для магазинов Санкт-Петербурга.

--Столбцы в результирующей таблице:

--DATE_, SHOPNUMBER, CATEGORY, PREV_SALES


-- Создаю временную таблицу с суммарными продажами по каждой категории товаров
WITH sales_sum AS (
    SELECT 
        -- Извлекаю дату продажи, магазин и категорию товара
        s."DATE" AS DATE_,
        s."SHOPNUMBER",
        g."CATEGORY",
        -- Суммирую продажи по каждому товару, умножая количество на цену
        SUM(s."QTY" * g."PRICE") AS total_sales
    FROM 
        sales s
    -- Соединяю таблицу продаж с таблицей магазинов по номеру магазина
    JOIN 
        shops sh ON s."SHOPNUMBER" = sh."SHOPNUMBER"
    -- Соединяю таблицу продаж с таблицей товаров по ID товара
    JOIN 
        goods g ON s."ID_GOOD" = g."ID_GOOD"
    WHERE 
        -- Ограничиваю выборку только магазинами, расположенными в Санкт-Петербурге
        sh."CITY" = 'СПб'
    -- Группирую данные по дате, номеру магазина и категории товара для подсчёта суммарных продаж
    GROUP BY 
        s."DATE", s."SHOPNUMBER", g."CATEGORY"
)

-- Основной запрос для расчёта продаж и сравнения с предыдущими продажами
SELECT 
    ss.DATE_ AS DATE_,  -- Дата продажи
    ss."SHOPNUMBER",    -- Номер магазина
    ss."CATEGORY",      -- Категория товара
    -- Использую функцию LAG для получения значения продаж за предыдущий день
    Lag(ss.total_sales, 1, 0) OVER (PARTITION BY ss."SHOPNUMBER", ss."CATEGORY" ORDER BY ss.DATE_) AS PREV_SALES
FROM 
    sales_sum ss
-- Сортирую результат по номеру магазина, категории товара и дате
ORDER BY 
    ss."SHOPNUMBER", ss."CATEGORY", ss.DATE_;










--Часть 3:

--Создайте таблицу query (количество строк - порядка 20) с данными о поисковых запросах на маркетплейсе.

--Поля в таблице: searchid, year, month, day, userid, ts, devicetype, deviceid, query. ts- время запроса в формате unix.

--Рекомендация по наполнению столбца query: Заносите последовательные поисковые запросы. Например, к, ку, куп, купить, купить кур, купить куртку.


CREATE TABLE query (
    searchid SERIAL PRIMARY KEY,
    year INT,
    month INT,
    day INT,
    userid INT,
    ts BIGINT,
    devicetype VARCHAR(20),
    deviceid VARCHAR(50),
    query VARCHAR(255)
);

INSERT INTO query (year, month, day, userid, ts, devicetype, deviceid, query)
VALUES
-- Для Android (уже вставлены ранее)
(2024, 11, 20, 1, 1711170500, 'android', 'device123', 'к'),
(2024, 11, 20, 1, 1711170510, 'android', 'device123', 'ку'),
(2024, 11, 20, 1, 1711170520, 'android', 'device123', 'куп'),
(2024, 11, 20, 1, 1711170530, 'android', 'device123', 'купить'),
(2024, 11, 20, 1, 1711170540, 'android', 'device123', 'купить кур'),
(2024, 11, 20, 1, 1711170550, 'android', 'device123', 'купить курт'),
(2024, 11, 20, 2, 1711170600, 'android', 'device456', 'ноут'),
(2024, 11, 20, 2, 1711170610, 'android', 'device456', 'ноутб'),
(2024, 11, 20, 2, 1711170620, 'android', 'device456', 'ноутбук'),
(2024, 11, 20, 2, 1711170630, 'android', 'device456', 'ноутбук асус'),
(2024, 11, 20, 3, 1711170700, 'android', 'device789', 'сумк'),
(2024, 11, 20, 3, 1711170710, 'android', 'device789', 'сумка'),
(2024, 11, 20, 3, 1711170720, 'android', 'device789', 'сумка женская'),
(2024, 11, 20, 4, 1711170800, 'android', 'device123', 'книга'),
(2024, 11, 20, 4, 1711170810, 'android', 'device123', 'книга по'),
(2024, 11, 20, 4, 1711170820, 'android', 'device123', 'книга по программированию'),
(2024, 11, 20, 5, 1711170900, 'android', 'device101', 'телевизор'),
(2024, 11, 20, 5, 1711170910, 'android', 'device101', 'телевизор samsung'),
(2024, 11, 20, 5, 1711170920, 'android', 'device101', 'телевизор samsung 4k'),
(2024, 11, 20, 6, 1711171000, 'android', 'device111', 'кроссовк'),
(2024, 11, 20, 6, 1711171010, 'android', 'device111', 'кроссовки'),
(2024, 11, 20, 6, 1711171020, 'android', 'device111', 'кроссовки nike'),
(2024, 11, 20, 7, 1711171100, 'android', 'device222', 'планшет'),
(2024, 11, 20, 7, 1711171110, 'android', 'device222', 'планшет samsung'),

-- Для iPhone
(2024, 11, 20, 8, 1711171200, 'iphone', 'device333', 'айфо'),
(2024, 11, 20, 8, 1711171210, 'iphone', 'device333', 'айфон'),
(2024, 11, 20, 8, 1711171220, 'iphone', 'device333', 'айфон 13'),
(2024, 11, 20, 8, 1711171230, 'iphone', 'device333', 'айфон 13 pro'),
(2024, 11, 20, 9, 1711171300, 'iphone', 'device444', 'мобильн'),
(2024, 11, 20, 9, 1711171310, 'iphone', 'device444', 'мобильный'),
(2024, 11, 20, 9, 1711171320, 'iphone', 'device444', 'мобильный телефон'),
(2024, 11, 20, 9, 1711171330, 'iphone', 'device444', 'мобильный телефон apple'),
(2024, 11, 20, 10, 1711171400, 'iphone', 'device555', 'наушн'),
(2024, 11, 20, 10, 1711171410, 'iphone', 'device555', 'наушники'),
(2024, 11, 20, 10, 1711171420, 'iphone', 'device555', 'наушники apple'),
(2024, 11, 20, 11, 1711171500, 'iphone', 'device666', 'часов'),
(2024, 11, 20, 11, 1711171510, 'iphone', 'device666', 'часы'),
(2024, 11, 20, 11, 1711171520, 'iphone', 'device666', 'часы apple'),
(2024, 11, 20, 12, 1711171600, 'iphone', 'device777', 'кейс'),
(2024, 11, 20, 12, 1711171610, 'iphone', 'device777', 'кейс для айфона'),
(2024, 11, 20, 12, 1711171620, 'iphone', 'device777', 'кейс для айфона 13'),
(2024, 11, 20, 13, 1711171700, 'iphone', 'device888', 'зарядк'),
(2024, 11, 20, 13, 1711171710, 'iphone', 'device888', 'зарядка'),
(2024, 11, 20, 13, 1711171720, 'iphone', 'device888', 'зарядка для айфона');












--Для каждого запроса определим значение is_final:

--Если пользователь вбил запрос (с определенного устройства), и после данного запроса больше ничего не искал, то значение равно 1
--Если пользователь вбил запрос (с определенного устройства), и до следующего запроса прошло более 3х минут, то значение также равно 1
--Если пользователь вбил запрос (с определенного устройства), И следующий запрос был короче, И до следующего запроса прошло прошло более минуты, то значение равно 2
--Иначе - значение равно 0
--Выведите данные о запросах в определенный день (выберите сами), у которых is_final пользователей устройства android равен 1 или 2.



WITH query_with_next AS (
    
    SELECT
        q.year,  -- Год запроса
        q.month, -- Месяц запроса
        q.day,   -- День запроса
        q.userid, -- Идентификатор пользователя
        q.ts,    -- Время запроса в формате Unix
        q.devicetype, -- Тип устройства (например, android)
        q.deviceid,   -- Идентификатор устройства
        q.query,      -- Текущий поисковый запрос
        LEAD(q.query) OVER (PARTITION BY q.userid, q.deviceid ORDER BY q.ts) AS next_query, -- Следующий поисковый запрос того же пользователя и устройства
        LEAD(q.ts) OVER (PARTITION BY q.userid, q.deviceid ORDER BY q.ts) AS next_ts -- Время следующего запроса того же пользователя и устройства
    FROM query q
    WHERE q.devicetype = 'android'  -- Я фильтрую только устройства типа 'android'
    AND q.year = 2024 AND q.month = 11 AND q.day = 20  -- И только запросы за 20 ноября 2024 года
),
query_with_is_final AS (
    -- Теперь я вычисляю значение поля 'is_final' на основе определённых условий
    SELECT
        q.year,  -- Год запроса
        q.month, -- Месяц запроса
        q.day,   -- День запроса
        q.userid, -- Идентификатор пользователя
        q.ts,    -- Время запроса
        q.devicetype, -- Тип устройства
        q.deviceid,   -- Идентификатор устройства
        q.query,      -- Текущий запрос
        q.next_query, -- Следующий запрос
        q.next_ts,    -- Время следующего запроса
        CASE
            -- Если следующий запрос отсутствует (пользователь не совершал других запросов) или между запросами прошло больше 3 минут (180 секунд)
            -- То я считаю этот запрос финальным и присваиваю ему значение 'is_final = 1'
            WHEN q.next_query IS NULL OR EXTRACT(EPOCH FROM (TO_TIMESTAMP(q.next_ts) - TO_TIMESTAMP(q.ts))) > 180 THEN 1
            -- Если следующий запрос короче текущего  и между запросами прошло больше минуты (60 секунд)
            -- То я считаю, что это тоже финальный запрос и присваиваю ему значение 'is_final = 2'
            WHEN LENGTH(q.next_query) < LENGTH(q.query) 
                AND EXTRACT(EPOCH FROM (TO_TIMESTAMP(q.next_ts) - TO_TIMESTAMP(q.ts))) > 60 THEN 2
            -- В остальных случаях я присваиваю 'is_final = 0', что означает, что это не финальный запрос
            ELSE 0
        END AS is_final
    FROM query_with_next q  -- Я использую результаты из первого CTE, который добавил информацию о следующем запросе и времени
)
-- На последнем шаге я извлекаю все нужные поля и фильтрую результаты по 'is_final', оставляя только те запросы, которые были финальными (значение is_final = 1 или 2)
SELECT
    year,   -- Год запроса
    month,  -- Месяц запроса
    day,    -- День запроса
    userid, -- Идентификатор пользователя
    ts,     -- Время запроса
    devicetype, -- Тип устройства
    deviceid,   -- Идентификатор устройства
    query,      -- Текущий запрос
    next_query, -- Следующий запрос
    is_final    -- Значение, которое определяет, является ли запрос финальным
FROM query_with_is_final -- Я использую результаты из второго CTE
WHERE is_final IN (1, 2)  -- Я фильтрую только те записи, где запрос является финальным (is_final = 1 или 2)
ORDER BY ts;  -- Сортирую по времени запроса для того, чтобы результаты шли в хронологическом порядке


